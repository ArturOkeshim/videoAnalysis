# Извлечение ценных кадров из видео

Класс предназначен для автоматического анализа видео с презентациями, извлечения наиболее значимых кадров (слайдов). Использует API Gemini для анализа изображений. Средняя точность извлечения кадров: 75-85% (тестировался на датасете, предоставленном в рамках стажировки). 

Ссылка на отчет:
https://drive.google.com/drive/folders/1l1BGnX6TKbUPwF_GfpVPaNhjdHcOFOL9?usp=sharing

## Быстрый старт

1. Установка зависимостей

Перед запуском убедитесь, что в вашем окружении установлены все необходимые библиотеки:

```bash
pip install openai tqdm opencv-python openpyxl Pillow
```

2. Подготовка файлов

Для работы алгоритма потребуется подготовить два файла:

- Подготовьте видеофайл (.mp4, .avi и т.д.)

- Подготовьте субтитры в формате .srt. 

Чтобы подготовить субтитры, необходимо транскрибировать файл с использованием whisper large v-3. 
Ccылка на блоткнот: https://colab.research.google.com/drive/1-t3HiABGa1CLrNCbZDfbdGI-1UkFLqI5?usp=sharing

3. Оплата подписки на VSE GPT

Api работает через сервис VSE GPT. Перед началом работы необходимо зарегистрироваться на сервисе и оплатить подписку. 
https://vsegpt.ru/Docs/Tariffs

Стоимость подписки равна 399 рублям в месяц + стоимость запросов. В алгоритме используется самая дешевая Vision модель, которая есть. По итогам тестов получается, что стоимость анализа видео = кол-во минут * 0.6. То есть, примерно 5-7 рублей может быть потрачено на анализ 10 минутного видео. Стоимость может слегка варьироваться из-за количества важных кадров, которые есть в видео. 

4. Запуск программы

При подключении программы как модуля создайте экземпляр класса и запустите функцию extract_valuable_frames. Например:

   detector = Gemini_Flash_Slide_Detection()
   valuable_frames = detector.extract_valuable_frames()

В консоли введите ваше ключ API, путь к SRT-файлу и путь к видео.

Анализ 10-минутного видео может занимать до 20 минут, из-за ограничений скорости обработки API запросов. 
Примерное рассчетное время окончания = кол-во минут в видео * 2.

5. Результаты

Результаты анализа будут добавлены в папку "Gemini_frames".

# Важно

   Для работы требуется стабильное интернет-соединение (используется API)

   Обработка видео может занять время (зависит от длины видео и количества слайдов)

   API-ключ не сохраняется в программе после завершения работы



## Подробное описание

Класс `Gemini_Flash_Slide_Detection`

## Назначение
Класс предназначен для автоматического анализа видео с презентациями, извлечения наиболее значимых кадров (слайдов) и их организации в структурированный Excel-файл. Использует API Gemini для анализа изображений.

---

## Методы класса

### 1. `__init__(self)`
**Инициализация детектора**

**Параметры:**
- Запрашивает API ключ через консольный ввод
- Устанавливает параметры по умолчанию:
    `api_key`: None                                                       (Ключ API VSE GPT)
    `client`: OpenAI(api_key=0, base_url="https://api.vsegpt.ru/v1")      (API клиент VSE GPT)
    `model_name`: "vis-google/gemini-2.5-flash-pre-05-20"                 (Точное наименование Vision-модели)
    `temperature`: 0                                                      (Температура ответа. Специально снижена, чтобы модель ничего не придумывала)      
    `max_tokens`: 10                                                      (Ограниченный размер ответа, чтобы не тратить лишние деньги) 
    `end_seconds`: 2                                                      (Время в секундах до конца предложения спикера) 
    `output_dir`:'Gemini_frames'                                          (Папка, в которой появятся отобранные кадры) 
    `srt_path`: None                                                      (Путь к SRT-файлу) 
    `video_path`: None                                                    (Путь к видео-файлу)

Не рекоммендуется менять параметры, кроме output_dir, srt_path, video_path. Остальные параметры обеспечивают корректный ответ модели.
Если повысить, например, температуру, модель может забыть инструкцию, и ответить в неправильном формате.

---

### 2. `_clear_output_dir(self)`
**Очистка выходной директории**

Удаляет все файлы в папке `output_dir` без рекурсивного удаления поддиректорий.

---

### 3. `_parse_time(time_str)` (static)
**Парсинг временной метки**

**Параметры:**
- `time_str`: строка времени в формате "HH:MM:SS,mmm"

**Возвращает:**
- Время в секундах (float)

**Пример:**
```python
_parse_time("01:23:45,678") → 5025.678
```

---

### 4. `_seconds_to_frame_path(self, seconds, output_dir)` (static)
**Генерация пути к файлу кадра**

**Параметры:**
- `seconds`: время в секундах
- `output_dir`: целевая директория

**Возвращает:**
- Полный путь к файлу в формате `frame_MMm_SSs_MMMms.png`

---

### 5. `_path_to_seconds(frame_path)` (static)
**Извлечение времени из имени файла**

**Параметры:**
- `frame_path`: путь к файлу кадра

**Возвращает:**
- Время в секундах (float)

---

### 6. `_ensure_dir(directory)` (static)
**Создание директории при необходимости**

**Параметры:**
- `directory`: путь к директории

---

### 7. `_image_to_base64(file_path)` (static)
**Кодирование изображения в base64**

**Параметры:**
- `file_path`: путь к изображению

**Возвращает:**
- Строку в формате `data:image/png;base64,...`

---

### 8. `_find_text_in_entries(second, entries)` (static)
**Поиск текста по временной метке**

**Параметры:**
- `second`: временная метка
- `entries`: список записей из SRT

**Возвращает:**
- Соответствующий текст или None

---

### 9. `parse_srt(self)`
**Парсинг SRT-файла**

**Возвращает:**
- Список кортежей формата `(start_sec, end_sec, text)`

**Исключения:**
- Выводит ошибку при проблемах чтения файла

---

### 10. `get_end_sentence_frame_times(self, entries)`
**Получение временных меток конца реплик**

**Параметры:**
- `entries`: результат `parse_srt()`

**Возвращает:**
- Список временных меток (end_sec - 1)

---

### 11. `extract_frames(self, frame_times, progress_bar=True)`
**Извлечение кадров из видео**

**Параметры:**
- `frame_times`: список временных меток
- `progress_bar`: отображать прогресс-бар

**Возвращает:**
- Список путей к сохраненным кадрам

**Исключения:**
- `ValueError` при проблемах открытия видео

---

### 12. `detect_theme_change(self, list_of_frames)`
**Анализ смены тем/слайдов**

**Параметры:**
- `list_of_frames`: список путей к кадрам

**Возвращает:**
- Список кадров с изменением темы

**Логика работы:**
1. Сравнивает соседние кадры через Gemini API
2. Классифицирует как:
   - `--1--`: постепенное изменение
   - `--2--`: смена темы/слайда

---

### 13. `is_speaker_only(self, entries, theme_frames)`
**Фильтрация кадров без полезного контента**

**Параметры:**
- `entries`: результат `parse_srt()`
- `theme_frames`: список кадров

**Возвращает:**
- Список кадров с полезным контентом

**Критерии отбора:**
- `--1--`: только лицо спикера
- `--2--`: полезные слайды/диаграммы

---

### 14. `select_best_frame(self, clear_frames)`
**Выбор оптимального кадра из трех вариантов**

**Параметры:**
- `clear_frames`: отфильтрованные кадры

**Возвращает:**
- Список лучших кадров

**Логика:**
Для каждого кадра анализирует:
1. Предыдущий (-1 сек)
2. Текущий
3. Следующий (+1 сек)

---

### 15. `delete_extra_frames(self, list_of_chosen_frames)`
**Удаление лишних кадров**

**Параметры:**
- `list_of_chosen_frames`: финальный список кадров

---

### 16. `prepare_excel(self, list_of_chosen_frames, name=None)`
**Создание Excel-файла с кадрами**

**Параметры:**
- `list_of_chosen_frames`: список кадров
- `name`: имя файла (по умолчанию "images_in_excel_13rs.xlsx")

**Формат вывода:**
- Каждый кадр в отдельной строке
- Автомасштабирование изображений

---

### 17. `extract_valuable_frames(self)`
**Основной рабочий процесс**

**Возвращает:**
- Список финальных кадров

**Последовательность операций:**
1. Очистка выходной директории
2. Парсинг SRT
3. Извлечение кадров
4. Детекция смены тем
5. Фильтрация кадров
6. Выбор лучших вариантов
7. Очистка лишних файлов

---

## Пример использования
```python
detector = Gemini_Flash_Slide_Detection()
detector.srt_path = "presentation.srt"
detector.video_path = "presentation.mp4"
valuable_frames = detector.extract_valuable_frames()
detector.prepare_excel(valuable_frames, "my_presentation.xlsx")
```

## Требования
- Python 3.7+
- Зависимости: `openai`, `opencv-python`, `tqdm`, `openpyxl`, `Pillow`
